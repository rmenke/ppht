<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PPHT: ppht::accumulator&lt; Count, Raster &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PPHT
   &#160;<span id="projectnumber">1.0.5</span>
   </div>
   <div id="projectbrief">An implementation of PPHT as a header-only library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceppht.html">ppht</a></li><li class="navelem"><a class="el" href="classppht_1_1accumulator.html">accumulator</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classppht_1_1accumulator-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ppht::accumulator&lt; Count, Raster &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A collection of counters for line candidates.  
 <a href="classppht_1_1accumulator.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="accumulator_8hpp_source.html">accumulator.hpp</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for ppht::accumulator&lt; Count, Raster &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classppht_1_1accumulator__coll__graph.svg" width="146" height="136"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a520d44b081be8797bf89dc9afbefd6a0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classppht_1_1accumulator.html#a520d44b081be8797bf89dc9afbefd6a0">accumulator</a> (std::size_t rows, std::size_t cols, <a class="el" href="structppht_1_1parameters.html">parameters</a> const &amp;param, <a class="el" href="classppht_1_1accumulator.html#a92ee869bb03a6ced5ecf470d4328f5c4">seed_t</a> seed=std::random_device{}())</td></tr>
<tr class="memdesc:a520d44b081be8797bf89dc9afbefd6a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an instance of <a class="el" href="classppht_1_1accumulator.html">accumulator</a>.  <a href="#a520d44b081be8797bf89dc9afbefd6a0">More...</a><br /></td></tr>
<tr class="separator:a520d44b081be8797bf89dc9afbefd6a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ff140558c3734deb891878d3fec802f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceppht.html#acefb02c86eb6437a82dc24246107fda7">segment_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classppht_1_1accumulator.html#a8ff140558c3734deb891878d3fec802f">find_segment</a> (std::size_t theta, double rho)</td></tr>
<tr class="memdesc:a8ff140558c3734deb891878d3fec802f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the portion of the line that lies within the bounds of the bitmap.  <a href="#a8ff140558c3734deb891878d3fec802f">More...</a><br /></td></tr>
<tr class="separator:a8ff140558c3734deb891878d3fec802f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c160abbc583112e4706c4ce82ac389"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classppht_1_1accumulator.html#a02c160abbc583112e4706c4ce82ac389">vote</a> (<a class="el" href="namespaceppht.html#aaac7400c942264f91fe4775f927d80be">point_t</a> const &amp;p, <a class="el" href="namespaceppht.html#acefb02c86eb6437a82dc24246107fda7">segment_t</a> &amp;segment)</td></tr>
<tr class="memdesc:a02c160abbc583112e4706c4ce82ac389"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add all lines passing through the given point to the accumulator.  <a href="#a02c160abbc583112e4706c4ce82ac389">More...</a><br /></td></tr>
<tr class="separator:a02c160abbc583112e4706c4ce82ac389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81095d6f10832e7abae3d8c34d42f186"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classppht_1_1accumulator.html#a81095d6f10832e7abae3d8c34d42f186">unvote</a> (<a class="el" href="namespaceppht.html#aaac7400c942264f91fe4775f927d80be">point_t</a> const &amp;p)</td></tr>
<tr class="separator:a81095d6f10832e7abae3d8c34d42f186"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aecb19a75dc4daeb949a9fd06ac4e42e6"><td class="memItemLeft" align="right" valign="top">static std::pair&lt; std::size_t, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classppht_1_1accumulator.html#aecb19a75dc4daeb949a9fd06ac4e42e6">rho_info</a> (std::size_t rows, std::size_t cols, std::size_t max_theta) noexcept</td></tr>
<tr class="memdesc:aecb19a75dc4daeb949a9fd06ac4e42e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate parameters for scaling rho.  <a href="#aecb19a75dc4daeb949a9fd06ac4e42e6">More...</a><br /></td></tr>
<tr class="separator:aecb19a75dc4daeb949a9fd06ac4e42e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:a5e6bb0aed7790db516a3908fb9cf0a80"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classppht_1_1accumulator.html#a5e6bb0aed7790db516a3908fb9cf0a80">URBG</a> = std::default_random_engine</td></tr>
<tr class="memdesc:a5e6bb0aed7790db516a3908fb9cf0a80"><td class="mdescLeft">&#160;</td><td class="mdescRight">A uniform random bit generator.  <a href="#a5e6bb0aed7790db516a3908fb9cf0a80">More...</a><br /></td></tr>
<tr class="separator:a5e6bb0aed7790db516a3908fb9cf0a80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ee869bb03a6ced5ecf470d4328f5c4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classppht_1_1accumulator.html#a92ee869bb03a6ced5ecf470d4328f5c4">seed_t</a> = std::random_device::result_type</td></tr>
<tr class="memdesc:a92ee869bb03a6ced5ecf470d4328f5c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of seed for the <a class="el" href="classppht_1_1accumulator.html#a5e6bb0aed7790db516a3908fb9cf0a80">URBG</a>.  <a href="#a92ee869bb03a6ced5ecf470d4328f5c4">More...</a><br /></td></tr>
<tr class="separator:a92ee869bb03a6ced5ecf470d4328f5c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ae7a4f7f7ed9af6e71d551f218cd38536"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classppht_1_1accumulator.html#ae7a4f7f7ed9af6e71d551f218cd38536">scale_rho</a> (double unscaled_rho) const noexcept</td></tr>
<tr class="memdesc:ae7a4f7f7ed9af6e71d551f218cd38536"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a raw rho value to an index value.  <a href="#ae7a4f7f7ed9af6e71d551f218cd38536">More...</a><br /></td></tr>
<tr class="separator:ae7a4f7f7ed9af6e71d551f218cd38536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a793d5129b3dabe924a839bd5ccf3ffe2"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classppht_1_1accumulator.html#a793d5129b3dabe924a839bd5ccf3ffe2">unscale_rho</a> (double scaled_rho) const noexcept</td></tr>
<tr class="memdesc:a793d5129b3dabe924a839bd5ccf3ffe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a scaled rho value back to a raw value.  <a href="#a793d5129b3dabe924a839bd5ccf3ffe2">More...</a><br /></td></tr>
<tr class="separator:a793d5129b3dabe924a839bd5ccf3ffe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3d150514be932dee46295bba2b0aa86"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classppht_1_1accumulator.html#ae3d150514be932dee46295bba2b0aa86">accumulator</a> (std::size_t rows, std::size_t cols, std::size_t max_theta, const std::pair&lt; std::size_t, int &gt; &amp;<a class="el" href="classppht_1_1accumulator.html#aecb19a75dc4daeb949a9fd06ac4e42e6">rho_info</a>, double log_threshold, std::size_t min_trigger_points, <a class="el" href="classppht_1_1accumulator.html#a92ee869bb03a6ced5ecf470d4328f5c4">seed_t</a> seed) noexcept</td></tr>
<tr class="memdesc:ae3d150514be932dee46295bba2b0aa86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an instance of <a class="el" href="classppht_1_1accumulator.html">accumulator</a>.  <a href="#ae3d150514be932dee46295bba2b0aa86">More...</a><br /></td></tr>
<tr class="separator:ae3d150514be932dee46295bba2b0aa86"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:a836391184051253c1ddb8239b4f0212d"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a836391184051253c1ddb8239b4f0212d"><td class="memTemplItemLeft" align="right" valign="top">static T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classppht_1_1accumulator.html#a836391184051253c1ddb8239b4f0212d">clamp</a> (U value) noexcept</td></tr>
<tr class="memdesc:a836391184051253c1ddb8239b4f0212d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restrict the value to the range of the target type.  <a href="#a836391184051253c1ddb8239b4f0212d">More...</a><br /></td></tr>
<tr class="separator:a836391184051253c1ddb8239b4f0212d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a37106c56bcf48642217b214e60229444"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classppht_1_1trig__table.html">trig_table</a> const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classppht_1_1accumulator.html#a37106c56bcf48642217b214e60229444">_trig</a></td></tr>
<tr class="memdesc:a37106c56bcf48642217b214e60229444"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trigonometry tables quantized by max_theta.  <a href="#a37106c56bcf48642217b214e60229444">More...</a><br /></td></tr>
<tr class="separator:a37106c56bcf48642217b214e60229444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa791a41afd8aa1774a6bcb34f0ca286d"><td class="memItemLeft" align="right" valign="top">std::size_t const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classppht_1_1accumulator.html#aa791a41afd8aa1774a6bcb34f0ca286d">_rows</a></td></tr>
<tr class="memdesc:aa791a41afd8aa1774a6bcb34f0ca286d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Height of bitmap image.  <a href="#aa791a41afd8aa1774a6bcb34f0ca286d">More...</a><br /></td></tr>
<tr class="separator:aa791a41afd8aa1774a6bcb34f0ca286d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43000d45677f61f8f2069602da3eea06"><td class="memItemLeft" align="right" valign="top">std::size_t const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classppht_1_1accumulator.html#a43000d45677f61f8f2069602da3eea06">_cols</a></td></tr>
<tr class="memdesc:a43000d45677f61f8f2069602da3eea06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Width of bitmap image.  <a href="#a43000d45677f61f8f2069602da3eea06">More...</a><br /></td></tr>
<tr class="separator:a43000d45677f61f8f2069602da3eea06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15ab5949c754cb724863eb0539af7317"><td class="memItemLeft" align="right" valign="top">int const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classppht_1_1accumulator.html#a15ab5949c754cb724863eb0539af7317">_rho_scale</a></td></tr>
<tr class="memdesc:a15ab5949c754cb724863eb0539af7317"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exponent by which to scale raw rho values.  <a href="#a15ab5949c754cb724863eb0539af7317">More...</a><br /></td></tr>
<tr class="separator:a15ab5949c754cb724863eb0539af7317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5096b40064eeb7b961f2f00158163ff2"><td class="memItemLeft" align="right" valign="top">double const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classppht_1_1accumulator.html#a5096b40064eeb7b961f2f00158163ff2">_log_threshold</a></td></tr>
<tr class="memdesc:a5096b40064eeb7b961f2f00158163ff2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Log-probability threshold for rejecting the null hypothesis.  <a href="#a5096b40064eeb7b961f2f00158163ff2">More...</a><br /></td></tr>
<tr class="separator:a5096b40064eeb7b961f2f00158163ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a627ac1a7abe04abf8ce01d630c6d8420"><td class="memItemLeft" align="right" valign="top">Count const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classppht_1_1accumulator.html#a627ac1a7abe04abf8ce01d630c6d8420">_min_trigger_points</a></td></tr>
<tr class="memdesc:a627ac1a7abe04abf8ce01d630c6d8420"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of points required to trigger a channel scan.  <a href="#a627ac1a7abe04abf8ce01d630c6d8420">More...</a><br /></td></tr>
<tr class="separator:a627ac1a7abe04abf8ce01d630c6d8420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0685499b80d4adbb6cb3799651ab53cf"><td class="memItemLeft" align="right" valign="top">Raster&lt; Count &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classppht_1_1accumulator.html#a0685499b80d4adbb6cb3799651ab53cf">_counters</a></td></tr>
<tr class="memdesc:a0685499b80d4adbb6cb3799651ab53cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix of counters (quantized \(\theta\rho\)-space).  <a href="#a0685499b80d4adbb6cb3799651ab53cf">More...</a><br /></td></tr>
<tr class="separator:a0685499b80d4adbb6cb3799651ab53cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a362e2e2ce01e990641096e22da5475f9"><td class="memItemLeft" align="right" valign="top">Count&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classppht_1_1accumulator.html#a362e2e2ce01e990641096e22da5475f9">_votes</a> = 0</td></tr>
<tr class="memdesc:a362e2e2ce01e990641096e22da5475f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Votes still in effect.  <a href="#a362e2e2ce01e990641096e22da5475f9">More...</a><br /></td></tr>
<tr class="separator:a362e2e2ce01e990641096e22da5475f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af05329f24d02f498ce4961823f4e3fc1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classppht_1_1accumulator.html#a5e6bb0aed7790db516a3908fb9cf0a80">URBG</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classppht_1_1accumulator.html#af05329f24d02f498ce4961823f4e3fc1">_urbg</a></td></tr>
<tr class="memdesc:af05329f24d02f498ce4961823f4e3fc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random number generator.  <a href="#af05329f24d02f498ce4961823f4e3fc1">More...</a><br /></td></tr>
<tr class="separator:af05329f24d02f498ce4961823f4e3fc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class Count = std::uint16_t, template&lt; class &gt; class Raster = raster&gt;<br />
class ppht::accumulator&lt; Count, Raster &gt;</h3>

<p>A collection of counters for line candidates. </p>
<p>The accumulator class keeps track of the matrix of counters (indexed by their \(\theta\rho\) values) and provides operations for incrementing and decrementing the values, as well as converting a line in \(\theta\rho\)-form to a line segment within the bounds of the image.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Count</td><td>the type used for the counters</td></tr>
    <tr><td class="paramname">Raster</td><td>the type used for the matrix of counters </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a92ee869bb03a6ced5ecf470d4328f5c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92ee869bb03a6ced5ecf470d4328f5c4">&sect;&nbsp;</a></span>seed_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Count  = std::uint16_t, template&lt; class &gt; class Raster = raster&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classppht_1_1accumulator.html">ppht::accumulator</a>&lt; Count, Raster &gt;::<a class="el" href="classppht_1_1accumulator.html#a92ee869bb03a6ced5ecf470d4328f5c4">seed_t</a> =  std::random_device::result_type</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The type of seed for the <a class="el" href="classppht_1_1accumulator.html#a5e6bb0aed7790db516a3908fb9cf0a80">URBG</a>. </p>

</div>
</div>
<a id="a5e6bb0aed7790db516a3908fb9cf0a80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e6bb0aed7790db516a3908fb9cf0a80">&sect;&nbsp;</a></span>URBG</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Count  = std::uint16_t, template&lt; class &gt; class Raster = raster&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classppht_1_1accumulator.html">ppht::accumulator</a>&lt; Count, Raster &gt;::<a class="el" href="classppht_1_1accumulator.html#a5e6bb0aed7790db516a3908fb9cf0a80">URBG</a> =  std::default_random_engine</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A uniform random bit generator. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae3d150514be932dee46295bba2b0aa86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3d150514be932dee46295bba2b0aa86">&sect;&nbsp;</a></span>accumulator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Count  = std::uint16_t, template&lt; class &gt; class Raster = raster&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classppht_1_1accumulator.html">ppht::accumulator</a>&lt; Count, Raster &gt;::<a class="el" href="classppht_1_1accumulator.html">accumulator</a> </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>max_theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; std::size_t, int &gt; &amp;&#160;</td>
          <td class="paramname"><em>rho_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>log_threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>min_trigger_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classppht_1_1accumulator.html#a92ee869bb03a6ced5ecf470d4328f5c4">seed_t</a>&#160;</td>
          <td class="paramname"><em>seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an instance of <a class="el" href="classppht_1_1accumulator.html">accumulator</a>. </p>
<p>This constructor is called with the results of manipulation of the members of the <a class="el" href="structppht_1_1parameters.html">parameters</a> object: the logarithm of the threshold and the computed range and scale factor for rho.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>the height of the image</td></tr>
    <tr><td class="paramname">cols</td><td>the width of the image</td></tr>
    <tr><td class="paramname">max_theta</td><td>the number of parts per semiturn</td></tr>
    <tr><td class="paramname">rho_info</td><td>the maximum value a scaled rho can take and the scale factor</td></tr>
    <tr><td class="paramname">log_threshold</td><td>the natural logarithm of the threshold at which we reject the null hypothesis</td></tr>
    <tr><td class="paramname">min_trigger_points</td><td>the number of colinear points required before testing the null hypothesis</td></tr>
    <tr><td class="paramname">seed</td><td>the seed for the URBG </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a520d44b081be8797bf89dc9afbefd6a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a520d44b081be8797bf89dc9afbefd6a0">&sect;&nbsp;</a></span>accumulator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Count  = std::uint16_t, template&lt; class &gt; class Raster = raster&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classppht_1_1accumulator.html">ppht::accumulator</a>&lt; Count, Raster &gt;::<a class="el" href="classppht_1_1accumulator.html">accumulator</a> </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structppht_1_1parameters.html">parameters</a> const &amp;&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classppht_1_1accumulator.html#a92ee869bb03a6ced5ecf470d4328f5c4">seed_t</a>&#160;</td>
          <td class="paramname"><em>seed</em> = <code>std::random_device{}()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an instance of <a class="el" href="classppht_1_1accumulator.html">accumulator</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>the height of the bitmap</td></tr>
    <tr><td class="paramname">cols</td><td>the width of the bitmap</td></tr>
    <tr><td class="paramname">param</td><td>parameters controlling the operation of the accumulator</td></tr>
    <tr><td class="paramname">seed</td><td>the seed for the random number generator used to break ties. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a836391184051253c1ddb8239b4f0212d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a836391184051253c1ddb8239b4f0212d">&sect;&nbsp;</a></span>clamp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Count  = std::uint16_t, template&lt; class &gt; class Raster = raster&gt; </div>
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T <a class="el" href="classppht_1_1accumulator.html">ppht::accumulator</a>&lt; Count, Raster &gt;::clamp </td>
          <td>(</td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restrict the value to the range of the target type. </p>
<p>If the value is greater than the target type will allow, return the maximum value of the target type. If the value is less than the target type will allow, return the minimum value of the target type.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the target type</td></tr>
    <tr><td class="paramname">U</td><td>the source type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the value to convert</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value restricted to the limits of the target type </dd></dl>

</div>
</div>
<a id="a8ff140558c3734deb891878d3fec802f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ff140558c3734deb891878d3fec802f">&sect;&nbsp;</a></span>find_segment()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Count  = std::uint16_t, template&lt; class &gt; class Raster = raster&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceppht.html#acefb02c86eb6437a82dc24246107fda7">segment_t</a> <a class="el" href="classppht_1_1accumulator.html">ppht::accumulator</a>&lt; Count, Raster &gt;::find_segment </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rho</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the portion of the line that lies within the bounds of the bitmap. </p>
<p>Given a line in \(\theta\rho\)-space, return the line segment that is the portion of the line that intersects the bitmap.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">theta</td><td>the angle of the perpendicular</td></tr>
    <tr><td class="paramname">rho</td><td>the length of the perpendicular</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the portion of the line within the bounds of the bitmap in integral coordinates. </dd></dl>

</div>
</div>
<a id="aecb19a75dc4daeb949a9fd06ac4e42e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecb19a75dc4daeb949a9fd06ac4e42e6">&sect;&nbsp;</a></span>rho_info()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Count  = std::uint16_t, template&lt; class &gt; class Raster = raster&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::pair&lt;std::size_t, int&gt; <a class="el" href="classppht_1_1accumulator.html">ppht::accumulator</a>&lt; Count, Raster &gt;::rho_info </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>max_theta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate parameters for scaling rho. </p>
<p>Returns a pair containing the maximum scaled value rho can take on (height of the counter matrix) and the exponent by which rho should be scaled beforehand. The maximum scaled value is always an odd number.</p>
<p>If the pair returned is \((m, e)\), then \(\rho_\text{scaled} = \rho_\text{unscaled}\cdot2^e+(m-1)/2\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>the height of the bitmap in pixels</td></tr>
    <tr><td class="paramname">cols</td><td>the width of the bitmap in pixels</td></tr>
    <tr><td class="paramname">max_theta</td><td>the range of theta</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair containing scaling information for rho </dd></dl>

</div>
</div>
<a id="ae7a4f7f7ed9af6e71d551f218cd38536"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7a4f7f7ed9af6e71d551f218cd38536">&sect;&nbsp;</a></span>scale_rho()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Count  = std::uint16_t, template&lt; class &gt; class Raster = raster&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classppht_1_1accumulator.html">ppht::accumulator</a>&lt; Count, Raster &gt;::scale_rho </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>unscaled_rho</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a raw rho value to an index value. </p>
<p>Scale rho according to <a class="el" href="classppht_1_1accumulator.html#a15ab5949c754cb724863eb0539af7317">_rho_scale</a>, then add half the height of the counter matrix to it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">unscaled_rho</td><td>the raw rho value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a rho value that is scaled and translated</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classppht_1_1accumulator.html#a793d5129b3dabe924a839bd5ccf3ffe2" title="Convert a scaled rho value back to a raw value. ">unscale_rho()</a> </dd></dl>

</div>
</div>
<a id="a793d5129b3dabe924a839bd5ccf3ffe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a793d5129b3dabe924a839bd5ccf3ffe2">&sect;&nbsp;</a></span>unscale_rho()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Count  = std::uint16_t, template&lt; class &gt; class Raster = raster&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classppht_1_1accumulator.html">ppht::accumulator</a>&lt; Count, Raster &gt;::unscale_rho </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scaled_rho</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a scaled rho value back to a raw value. </p>
<p>Perform the transform of <a class="el" href="classppht_1_1accumulator.html#ae7a4f7f7ed9af6e71d551f218cd38536">scale_rho()</a> in reverse.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scaled_rho</td><td>the scaled rho value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a rho value that is no longer scaled or translated </dd></dl>

</div>
</div>
<a id="a81095d6f10832e7abae3d8c34d42f186"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81095d6f10832e7abae3d8c34d42f186">&sect;&nbsp;</a></span>unvote()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Count  = std::uint16_t, template&lt; class &gt; class Raster = raster&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classppht_1_1accumulator.html">ppht::accumulator</a>&lt; Count, Raster &gt;::unvote </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceppht.html#aaac7400c942264f91fe4775f927d80be">point_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Update the register by undoing a previous call to <a class="el" href="classppht_1_1accumulator.html#a02c160abbc583112e4706c4ce82ac389">vote()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the point to unregister </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a02c160abbc583112e4706c4ce82ac389"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02c160abbc583112e4706c4ce82ac389">&sect;&nbsp;</a></span>vote()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Count  = std::uint16_t, template&lt; class &gt; class Raster = raster&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classppht_1_1accumulator.html">ppht::accumulator</a>&lt; Count, Raster &gt;::vote </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceppht.html#aaac7400c942264f91fe4775f927d80be">point_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceppht.html#acefb02c86eb6437a82dc24246107fda7">segment_t</a> &amp;&#160;</td>
          <td class="paramname"><em>segment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add all lines passing through the given point to the accumulator. </p>
<p>Returns true if the likelihood of the largest count in the register exceeds the threshold.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the point to register</td></tr>
    <tr><td class="paramname">segment</td><td>set to the intersection of the line found and the bounds of the image only if the function returns true</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the number of votes for the line segment pass the threshold</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classppht_1_1accumulator.html#a81095d6f10832e7abae3d8c34d42f186">unvote()</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a43000d45677f61f8f2069602da3eea06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43000d45677f61f8f2069602da3eea06">&sect;&nbsp;</a></span>_cols</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Count  = std::uint16_t, template&lt; class &gt; class Raster = raster&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t const <a class="el" href="classppht_1_1accumulator.html">ppht::accumulator</a>&lt; Count, Raster &gt;::_cols</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Width of bitmap image. </p>

</div>
</div>
<a id="a0685499b80d4adbb6cb3799651ab53cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0685499b80d4adbb6cb3799651ab53cf">&sect;&nbsp;</a></span>_counters</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Count  = std::uint16_t, template&lt; class &gt; class Raster = raster&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Raster&lt;Count&gt; <a class="el" href="classppht_1_1accumulator.html">ppht::accumulator</a>&lt; Count, Raster &gt;::_counters</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matrix of counters (quantized \(\theta\rho\)-space). </p>

</div>
</div>
<a id="a5096b40064eeb7b961f2f00158163ff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5096b40064eeb7b961f2f00158163ff2">&sect;&nbsp;</a></span>_log_threshold</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Count  = std::uint16_t, template&lt; class &gt; class Raster = raster&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double const <a class="el" href="classppht_1_1accumulator.html">ppht::accumulator</a>&lt; Count, Raster &gt;::_log_threshold</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Log-probability threshold for rejecting the null hypothesis. </p>

</div>
</div>
<a id="a627ac1a7abe04abf8ce01d630c6d8420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a627ac1a7abe04abf8ce01d630c6d8420">&sect;&nbsp;</a></span>_min_trigger_points</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Count  = std::uint16_t, template&lt; class &gt; class Raster = raster&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Count const <a class="el" href="classppht_1_1accumulator.html">ppht::accumulator</a>&lt; Count, Raster &gt;::_min_trigger_points</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of points required to trigger a channel scan. </p>

</div>
</div>
<a id="a15ab5949c754cb724863eb0539af7317"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15ab5949c754cb724863eb0539af7317">&sect;&nbsp;</a></span>_rho_scale</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Count  = std::uint16_t, template&lt; class &gt; class Raster = raster&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int const <a class="el" href="classppht_1_1accumulator.html">ppht::accumulator</a>&lt; Count, Raster &gt;::_rho_scale</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exponent by which to scale raw rho values. </p>

</div>
</div>
<a id="aa791a41afd8aa1774a6bcb34f0ca286d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa791a41afd8aa1774a6bcb34f0ca286d">&sect;&nbsp;</a></span>_rows</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Count  = std::uint16_t, template&lt; class &gt; class Raster = raster&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t const <a class="el" href="classppht_1_1accumulator.html">ppht::accumulator</a>&lt; Count, Raster &gt;::_rows</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Height of bitmap image. </p>

</div>
</div>
<a id="a37106c56bcf48642217b214e60229444"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37106c56bcf48642217b214e60229444">&sect;&nbsp;</a></span>_trig</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Count  = std::uint16_t, template&lt; class &gt; class Raster = raster&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classppht_1_1trig__table.html">trig_table</a> const <a class="el" href="classppht_1_1accumulator.html">ppht::accumulator</a>&lt; Count, Raster &gt;::_trig</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trigonometry tables quantized by max_theta. </p>

</div>
</div>
<a id="af05329f24d02f498ce4961823f4e3fc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af05329f24d02f498ce4961823f4e3fc1">&sect;&nbsp;</a></span>_urbg</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Count  = std::uint16_t, template&lt; class &gt; class Raster = raster&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classppht_1_1accumulator.html#a5e6bb0aed7790db516a3908fb9cf0a80">URBG</a> <a class="el" href="classppht_1_1accumulator.html">ppht::accumulator</a>&lt; Count, Raster &gt;::_urbg</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Random number generator. </p>

</div>
</div>
<a id="a362e2e2ce01e990641096e22da5475f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a362e2e2ce01e990641096e22da5475f9">&sect;&nbsp;</a></span>_votes</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Count  = std::uint16_t, template&lt; class &gt; class Raster = raster&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Count <a class="el" href="classppht_1_1accumulator.html">ppht::accumulator</a>&lt; Count, Raster &gt;::_votes = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Votes still in effect. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>ppht/<a class="el" href="accumulator_8hpp_source.html">accumulator.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.12
</small></address>
</body>
</html>
