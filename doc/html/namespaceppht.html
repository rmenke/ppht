<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PPHT: ppht Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PPHT
   &#160;<span id="projectnumber">1.0.5</span>
   </div>
   <div id="projectbrief">An implementation of PPHT as a header-only library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">ppht Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The basic namespace of the library.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classppht_1_1accumulator.html">accumulator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A collection of counters for line candidates.  <a href="classppht_1_1accumulator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structppht_1_1axis__scanner.html">axis_scanner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A scanner optimized for lines parallel to an axis.  <a href="structppht_1_1axis__scanner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structppht_1_1bresenham__scanner.html">bresenham_scanner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A scanner based on Bresenham's line algorithm.  <a href="structppht_1_1bresenham__scanner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classppht_1_1channel.html">channel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstract container that wraps around a line segment.  <a href="classppht_1_1channel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structppht_1_1parameters.html">parameters</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The tunable parameters of the analyzer.  <a href="structppht_1_1parameters.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classppht_1_1point__set.html">point_set</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A collection of points surrounding a line segment.  <a href="classppht_1_1point__set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classppht_1_1raster.html">raster</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple class to manage a 2D array of elements.  <a href="classppht_1_1raster.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structppht_1_1scanner.html">scanner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for tracking the state required to advance a point along a segment.  <a href="structppht_1_1scanner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classppht_1_1state.html">state</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The state class represents the current state of the algorithm.  <a href="classppht_1_1state.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classppht_1_1trig__table.html">trig_table</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A precomputed table of sine and cosine values.  <a href="classppht_1_1trig__table.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structppht_1_1vec2d.html">vec2d</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple type representing a two-dimensional vector.  <a href="structppht_1_1vec2d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aaac7400c942264f91fe4775f927d80be"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceppht.html#aaac7400c942264f91fe4775f927d80be">point_t</a> = <a class="el" href="structppht_1_1vec2d.html">vec2d</a>&lt; std::size_t &gt;</td></tr>
<tr class="memdesc:aaac7400c942264f91fe4775f927d80be"><td class="mdescLeft">&#160;</td><td class="mdescRight">A basic integral point.  <a href="#aaac7400c942264f91fe4775f927d80be">More...</a><br /></td></tr>
<tr class="separator:aaac7400c942264f91fe4775f927d80be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a176d289e72fa78a8d942131fd2bcd47c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceppht.html#a176d289e72fa78a8d942131fd2bcd47c">offset_t</a> = <a class="el" href="structppht_1_1vec2d.html">vec2d</a>&lt; std::ptrdiff_t &gt;</td></tr>
<tr class="memdesc:a176d289e72fa78a8d942131fd2bcd47c"><td class="mdescLeft">&#160;</td><td class="mdescRight">An offset from a point.  <a href="#a176d289e72fa78a8d942131fd2bcd47c">More...</a><br /></td></tr>
<tr class="separator:a176d289e72fa78a8d942131fd2bcd47c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acefb02c86eb6437a82dc24246107fda7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceppht.html#acefb02c86eb6437a82dc24246107fda7">segment_t</a> = std::pair&lt; <a class="el" href="namespaceppht.html#aaac7400c942264f91fe4775f927d80be">point_t</a>, <a class="el" href="namespaceppht.html#aaac7400c942264f91fe4775f927d80be">point_t</a> &gt;</td></tr>
<tr class="memdesc:acefb02c86eb6437a82dc24246107fda7"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pair of points representing a line segment.  <a href="#acefb02c86eb6437a82dc24246107fda7">More...</a><br /></td></tr>
<tr class="separator:acefb02c86eb6437a82dc24246107fda7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a62df3910999f59d178dd7090a4c89d86"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceppht.html#a62df3910999f59d178dd7090a4c89d86">status_t</a> { <a class="el" href="namespaceppht.html#a62df3910999f59d178dd7090a4c89d86a0f45ad41c1c3261e309b3fd0bcab017a">unset</a>, 
<a class="el" href="namespaceppht.html#a62df3910999f59d178dd7090a4c89d86afb573f653d4d73258e47c80e98bad364">pending</a>, 
<a class="el" href="namespaceppht.html#a62df3910999f59d178dd7090a4c89d86ae6c5099536830b50645dc1f77dfc4873">voted</a>, 
<a class="el" href="namespaceppht.html#a62df3910999f59d178dd7090a4c89d86a68622b152a1cf239b30f26696906b3eb">done</a>
 }<tr class="memdesc:a62df3910999f59d178dd7090a4c89d86"><td class="mdescLeft">&#160;</td><td class="mdescRight">The status of a pixel in a state map.  <a href="namespaceppht.html#a62df3910999f59d178dd7090a4c89d86">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a62df3910999f59d178dd7090a4c89d86"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae8534014335620ab8cb9030d1e264853"><td class="memItemLeft" align="right" valign="top">static std::unique_ptr&lt; <a class="el" href="structppht_1_1scanner.html">scanner</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceppht.html#ae8534014335620ab8cb9030d1e264853">make_scanner</a> (<a class="el" href="namespaceppht.html#acefb02c86eb6437a82dc24246107fda7">segment_t</a> &amp;segment)</td></tr>
<tr class="separator:ae8534014335620ab8cb9030d1e264853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c40e4f435821fe542a141d43ee01b54"><td class="memItemLeft" align="right" valign="top">static std::set&lt; <a class="el" href="namespaceppht.html#a176d289e72fa78a8d942131fd2bcd47c">offset_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceppht.html#a2c40e4f435821fe542a141d43ee01b54">find_offsets</a> (<a class="el" href="namespaceppht.html#acefb02c86eb6437a82dc24246107fda7">segment_t</a> const &amp;segment, unsigned radius)</td></tr>
<tr class="memdesc:a2c40e4f435821fe542a141d43ee01b54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a set of offsets that are within a radius.  <a href="#a2c40e4f435821fe542a141d43ee01b54">More...</a><br /></td></tr>
<tr class="separator:a2c40e4f435821fe542a141d43ee01b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f07cf00007b3c094373ca8b4c7bf6bd"><td class="memTemplParams" colspan="2">template&lt;template&lt; class &gt; class Raster&gt; </td></tr>
<tr class="memitem:a9f07cf00007b3c094373ca8b4c7bf6bd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classppht_1_1point__set.html">point_set</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceppht.html#a9f07cf00007b3c094373ca8b4c7bf6bd">scan</a> (<a class="el" href="classppht_1_1state.html">state</a>&lt; Raster &gt; &amp;s, <a class="el" href="namespaceppht.html#acefb02c86eb6437a82dc24246107fda7">segment_t</a> const &amp;segment, unsigned radius, unsigned max_gap)</td></tr>
<tr class="memdesc:a9f07cf00007b3c094373ca8b4c7bf6bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trace a scan channel.  <a href="#a9f07cf00007b3c094373ca8b4c7bf6bd">More...</a><br /></td></tr>
<tr class="separator:a9f07cf00007b3c094373ca8b4c7bf6bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41a1d029f79e783306b59dadffea1bfd"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:a41a1d029f79e783306b59dadffea1bfd"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceppht.html#a41a1d029f79e783306b59dadffea1bfd">abs_diff</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:a41a1d029f79e783306b59dadffea1bfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to return the distance between two values.  <a href="#a41a1d029f79e783306b59dadffea1bfd">More...</a><br /></td></tr>
<tr class="separator:a41a1d029f79e783306b59dadffea1bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2d55cee3564bb363896e6ea93fd9434"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:aa2d55cee3564bb363896e6ea93fd9434"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceppht.html#aa2d55cee3564bb363896e6ea93fd9434">operator+</a> (const <a class="el" href="structppht_1_1vec2d.html">vec2d</a>&lt; T &gt; &amp;t, const <a class="el" href="structppht_1_1vec2d.html">vec2d</a>&lt; U &gt; &amp;u)</td></tr>
<tr class="memdesc:aa2d55cee3564bb363896e6ea93fd9434"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add two vectors.  <a href="#aa2d55cee3564bb363896e6ea93fd9434">More...</a><br /></td></tr>
<tr class="separator:aa2d55cee3564bb363896e6ea93fd9434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45405fef581967c9d8f4bb7d60bb0e41"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a45405fef581967c9d8f4bb7d60bb0e41"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceppht.html#a45405fef581967c9d8f4bb7d60bb0e41">operator*</a> (const <a class="el" href="structppht_1_1vec2d.html">vec2d</a>&lt; T &gt; &amp;t, const <a class="el" href="structppht_1_1vec2d.html">vec2d</a>&lt; U &gt; &amp;u)</td></tr>
<tr class="memdesc:a45405fef581967c9d8f4bb7d60bb0e41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutiply two vectors.  <a href="#a45405fef581967c9d8f4bb7d60bb0e41">More...</a><br /></td></tr>
<tr class="separator:a45405fef581967c9d8f4bb7d60bb0e41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d8007330c3cccf008b326c3faa37abd"><td class="memTemplParams" colspan="2">template&lt;class State , class Accumulator  = accumulator&lt;&gt;&gt; </td></tr>
<tr class="memitem:a7d8007330c3cccf008b326c3faa37abd"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespaceppht.html#acefb02c86eb6437a82dc24246107fda7">segment_t</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceppht.html#a7d8007330c3cccf008b326c3faa37abd">find_segments</a> (State &amp;&amp;<a class="el" href="classppht_1_1state.html">state</a>, const <a class="el" href="structppht_1_1parameters.html">parameters</a> &amp;param=<a class="el" href="structppht_1_1parameters.html">parameters</a>{}, std::random_device::result_type seed=std::random_device{}())</td></tr>
<tr class="memdesc:a7d8007330c3cccf008b326c3faa37abd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplified interface to the PPHT algorithm.  <a href="#a7d8007330c3cccf008b326c3faa37abd">More...</a><br /></td></tr>
<tr class="separator:a7d8007330c3cccf008b326c3faa37abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The basic namespace of the library. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a176d289e72fa78a8d942131fd2bcd47c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a176d289e72fa78a8d942131fd2bcd47c">&sect;&nbsp;</a></span>offset_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceppht.html#a176d289e72fa78a8d942131fd2bcd47c">ppht::offset_t</a> = typedef <a class="el" href="structppht_1_1vec2d.html">vec2d</a>&lt;std::ptrdiff_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An offset from a point. </p>

</div>
</div>
<a id="aaac7400c942264f91fe4775f927d80be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaac7400c942264f91fe4775f927d80be">&sect;&nbsp;</a></span>point_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceppht.html#aaac7400c942264f91fe4775f927d80be">ppht::point_t</a> = typedef <a class="el" href="structppht_1_1vec2d.html">vec2d</a>&lt;std::size_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A basic integral point. </p>

</div>
</div>
<a id="acefb02c86eb6437a82dc24246107fda7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acefb02c86eb6437a82dc24246107fda7">&sect;&nbsp;</a></span>segment_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceppht.html#acefb02c86eb6437a82dc24246107fda7">ppht::segment_t</a> = typedef std::pair&lt;<a class="el" href="namespaceppht.html#aaac7400c942264f91fe4775f927d80be">point_t</a>, <a class="el" href="namespaceppht.html#aaac7400c942264f91fe4775f927d80be">point_t</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A pair of points representing a line segment. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a62df3910999f59d178dd7090a4c89d86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62df3910999f59d178dd7090a4c89d86">&sect;&nbsp;</a></span>status_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceppht.html#a62df3910999f59d178dd7090a4c89d86">ppht::status_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The status of a pixel in a <a class="el" href="classppht_1_1state.html">state</a> map. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a62df3910999f59d178dd7090a4c89d86a0f45ad41c1c3261e309b3fd0bcab017a"></a>unset&#160;</td><td class="fielddoc"><p>Pixel is unset. </p>
</td></tr>
<tr><td class="fieldname"><a id="a62df3910999f59d178dd7090a4c89d86afb573f653d4d73258e47c80e98bad364"></a>pending&#160;</td><td class="fielddoc"><p>Pixel is set but not yet voted. </p>
</td></tr>
<tr><td class="fieldname"><a id="a62df3910999f59d178dd7090a4c89d86ae6c5099536830b50645dc1f77dfc4873"></a>voted&#160;</td><td class="fielddoc"><p>Pixel is set and voted. </p>
</td></tr>
<tr><td class="fieldname"><a id="a62df3910999f59d178dd7090a4c89d86a68622b152a1cf239b30f26696906b3eb"></a>done&#160;</td><td class="fielddoc"><p>Pixel has been incorporated into a segment. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a41a1d029f79e783306b59dadffea1bfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41a1d029f79e783306b59dadffea1bfd">&sect;&nbsp;</a></span>abs_diff()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto ppht::abs_diff </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function to return the distance between two values. </p>
<p>Returns the absolute difference of the two values, even if the values are unsigned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first value </td></tr>
    <tr><td class="paramname">b</td><td>the second value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the absolute value of the difference between the larger and smaller value. </dd></dl>

</div>
</div>
<a id="a2c40e4f435821fe542a141d43ee01b54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c40e4f435821fe542a141d43ee01b54">&sect;&nbsp;</a></span>find_offsets()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::set&lt;<a class="el" href="namespaceppht.html#a176d289e72fa78a8d942131fd2bcd47c">offset_t</a>&gt; ppht::find_offsets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceppht.html#acefb02c86eb6437a82dc24246107fda7">segment_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>segment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>radius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a set of offsets that are within a radius. </p>
<p>The number of offsets generated is controlled by the <code>radius</code> parameter. For a radius \(r\), the returned offsets will be \(0,1,\ldots,r\) pixels from the origin, along the perpendicular to the <code>segment</code> parameter. Both directions are considered, so \(2^r+1\) offsets will be generated before duplicates are removed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">segment</td><td>used to determine the orientation of the perpendicular.</td></tr>
    <tr><td class="paramname">radius</td><td>determines the number of offsets to calculate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a non-empty set of offsets.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceppht.html#a9f07cf00007b3c094373ca8b4c7bf6bd" title="Trace a scan channel. ">scan()</a> </dd></dl>

</div>
</div>
<a id="a7d8007330c3cccf008b326c3faa37abd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d8007330c3cccf008b326c3faa37abd">&sect;&nbsp;</a></span>find_segments()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class State , class Accumulator  = accumulator&lt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="namespaceppht.html#acefb02c86eb6437a82dc24246107fda7">segment_t</a>&gt; ppht::find_segments </td>
          <td>(</td>
          <td class="paramtype">State &amp;&amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structppht_1_1parameters.html">parameters</a> &amp;&#160;</td>
          <td class="paramname"><em>param</em> = <code><a class="el" href="structppht_1_1parameters.html">parameters</a>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::random_device::result_type&#160;</td>
          <td class="paramname"><em>seed</em> = <code>std::random_device{}()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simplified interface to the PPHT algorithm. </p>
<p>This function performs the full PPHT algorithm by iterating over the set points in the <code>state</code> matrix. The state matrix is destroyed in the process.</p>
<p>Typical use case:</p>
<div class="fragment"><div class="line"><a class="code" href="classppht_1_1state.html">ppht::state</a> state;</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> y = 0; y &lt; height; ++y) {</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> x = 0; x &lt; width; ++x) {</div><div class="line">    <span class="keywordflow">if</span> (is_set(bitmap, x, y)) {</div><div class="line">      state.<a class="code" href="classppht_1_1state.html#ac924d3997ba5265607c271d27defe368">mark_pending</a>({x, y});</div><div class="line">    }</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">auto</span> segments = <a class="code" href="namespaceppht.html#a7d8007330c3cccf008b326c3faa37abd">ppht::find_segments</a>(std::move(state));</div></div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">State</td><td>the class of the state parameter</td></tr>
    <tr><td class="paramname">Accumulator</td><td>the class to use for the accumulator</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>an initialized <a class="el" href="classppht_1_1state.html">ppht::state</a> object or something similar</td></tr>
    <tr><td class="paramname">param</td><td>optional tuning parameters to adjust the behavior of the algorithm</td></tr>
    <tr><td class="paramname">seed</td><td>a value to use as a seed for the URBG</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of line segments </dd></dl>

</div>
</div>
<a id="ae8534014335620ab8cb9030d1e264853"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8534014335620ab8cb9030d1e264853">&sect;&nbsp;</a></span>make_scanner()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::unique_ptr&lt;<a class="el" href="structppht_1_1scanner.html">scanner</a>&gt; ppht::make_scanner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceppht.html#acefb02c86eb6437a82dc24246107fda7">segment_t</a> &amp;&#160;</td>
          <td class="paramname"><em>segment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Factory function to create the appropriate scanner for the given segment. If the segment is not oriented correctly, then it will be corrected by exchanging the endpoints.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">segment</td><td>the segment to scan.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to an instance of <a class="el" href="structppht_1_1scanner.html">scanner</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>this function modifies its arguments. </dd></dl>

</div>
</div>
<a id="a45405fef581967c9d8f4bb7d60bb0e41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45405fef581967c9d8f4bb7d60bb0e41">&sect;&nbsp;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto ppht::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structppht_1_1vec2d.html">vec2d</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structppht_1_1vec2d.html">vec2d</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mutiply two vectors. </p>
<p>Returns the product of the individual components of the vectors as a new vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the first vector </td></tr>
    <tr><td class="paramname">u</td><td>the second vector</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector made from the products of the components </dd></dl>

</div>
</div>
<a id="aa2d55cee3564bb363896e6ea93fd9434"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2d55cee3564bb363896e6ea93fd9434">&sect;&nbsp;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto ppht::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structppht_1_1vec2d.html">vec2d</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structppht_1_1vec2d.html">vec2d</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add two vectors. </p>
<p>Returns the sum of the individual components of the vectors as a new vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the first vector </td></tr>
    <tr><td class="paramname">u</td><td>the second vector</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector made from the sums of the components </dd></dl>

</div>
</div>
<a id="a9f07cf00007b3c094373ca8b4c7bf6bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f07cf00007b3c094373ca8b4c7bf6bd">&sect;&nbsp;</a></span>scan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; class &gt; class Raster&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classppht_1_1point__set.html">point_set</a> ppht::scan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classppht_1_1state.html">state</a>&lt; Raster &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceppht.html#acefb02c86eb6437a82dc24246107fda7">segment_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>segment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>max_gap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trace a scan channel. </p>
<p>Iterate over the points in the scan channel described by <code>segment:</code> these are the canonical points. For each canonical point, examine all of the pixels within the channel radius. If any are set, add the canonical point to the current segment. At the end of a gap of <code>max_gap</code> pixels, end the current segment and start a new one. Upon completion of the scan, return the longest segment found so far.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the state object to update</td></tr>
    <tr><td class="paramname">segment</td><td>the canonical segment of the scan channel</td></tr>
    <tr><td class="paramname">radius</td><td>the number of pixels to check around the canonical segment</td></tr>
    <tr><td class="paramname">max_gap</td><td>the number of consecutive missed pixels that can appear in a segment</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classppht_1_1point__set.html">point_set</a> around the longest segment found</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if no points are set in the scan channel</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceppht.html#a2c40e4f435821fe542a141d43ee01b54" title="Return a set of offsets that are within a radius. ">find_offsets()</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.12
</small></address>
</body>
</html>
