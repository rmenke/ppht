<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PPHT: ppht Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PPHT<span id="projectnumber">&#160;1.0.9</span>
   </div>
   <div id="projectbrief">An implementation of PPHT as a header-only library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">ppht Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>The basic namespace of the library.  
<a href="namespaceppht.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classppht_1_1accumulator.html">accumulator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A collection of counters for line candidates.  <a href="classppht_1_1accumulator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structppht_1_1axis__scanner.html">axis_scanner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A scanner optimized for lines parallel to an axis.  <a href="structppht_1_1axis__scanner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structppht_1_1bresenham__scanner.html">bresenham_scanner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A scanner based on Bresenham's line algorithm.  <a href="structppht_1_1bresenham__scanner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classppht_1_1channel.html">channel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstract container that wraps around a line segment.  <a href="classppht_1_1channel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structppht_1_1parameters.html">parameters</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The tunable parameters of the analyzer.  <a href="structppht_1_1parameters.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classppht_1_1point__set.html">point_set</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A collection of points surrounding a line segment.  <a href="classppht_1_1point__set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structppht_1_1point__t.html">point_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A basic integral point.  <a href="structppht_1_1point__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classppht_1_1raster.html">raster</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple class to manage a 2D array of elements.  <a href="classppht_1_1raster.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structppht_1_1scanner.html">scanner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for tracking the state required to advance a point along a segment.  <a href="structppht_1_1scanner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classppht_1_1segment__t.html">segment_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classppht_1_1state.html">state</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The state class represents the current state of the algorithm.  <a href="classppht_1_1state.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classppht_1_1trig__table.html">trig_table</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A precomputed table of sine and cosine values.  <a href="classppht_1_1trig__table.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a62df3910999f59d178dd7090a4c89d86"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceppht.html#a62df3910999f59d178dd7090a4c89d86">status_t</a> { <a class="el" href="namespaceppht.html#a62df3910999f59d178dd7090a4c89d86a0f45ad41c1c3261e309b3fd0bcab017a">unset</a>
, <a class="el" href="namespaceppht.html#a62df3910999f59d178dd7090a4c89d86afb573f653d4d73258e47c80e98bad364">pending</a>
, <a class="el" href="namespaceppht.html#a62df3910999f59d178dd7090a4c89d86ae6c5099536830b50645dc1f77dfc4873">voted</a>
, <a class="el" href="namespaceppht.html#a62df3910999f59d178dd7090a4c89d86a68622b152a1cf239b30f26696906b3eb">done</a>
 }</td></tr>
<tr class="memdesc:a62df3910999f59d178dd7090a4c89d86"><td class="mdescLeft">&#160;</td><td class="mdescRight">The status of a pixel in a state map.  <a href="namespaceppht.html#a62df3910999f59d178dd7090a4c89d86">More...</a><br /></td></tr>
<tr class="separator:a62df3910999f59d178dd7090a4c89d86"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a65cf942dc09d432abd4bac48af8804ed"><td class="memTemplParams" colspan="2">template&lt;class State , class Accumulator  = accumulator&lt;&gt;&gt; </td></tr>
<tr class="memitem:a65cf942dc09d432abd4bac48af8804ed"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classppht_1_1segment__t.html">segment_t</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceppht.html#a65cf942dc09d432abd4bac48af8804ed">find_segments</a> (State &amp;&amp;<a class="el" href="classppht_1_1state.html">state</a>, const <a class="el" href="structppht_1_1parameters.html">parameters</a> &amp;param=<a class="el" href="structppht_1_1parameters.html">parameters</a>{}, std::random_device::result_type seed=std::random_device{}())</td></tr>
<tr class="memdesc:a65cf942dc09d432abd4bac48af8804ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplified interface to the PPHT algorithm.  <a href="namespaceppht.html#a65cf942dc09d432abd4bac48af8804ed">More...</a><br /></td></tr>
<tr class="separator:a65cf942dc09d432abd4bac48af8804ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa43fde4290ae78a00d1951918976316"><td class="memItemLeft" align="right" valign="top">static std::unique_ptr&lt; <a class="el" href="structppht_1_1scanner.html">scanner</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceppht.html#afa43fde4290ae78a00d1951918976316">make_scanner</a> (<a class="el" href="classppht_1_1segment__t.html">segment_t</a> &amp;segment)</td></tr>
<tr class="separator:afa43fde4290ae78a00d1951918976316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f7ea60086c280bdf0ffd08859d8523e"><td class="memTemplParams" colspan="2">template&lt;std::size_t Dim = 0, class RandomIt , class OutputIt &gt; </td></tr>
<tr class="memitem:a8f7ea60086c280bdf0ffd08859d8523e"><td class="memTemplItemLeft" align="right" valign="top">OutputIt&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceppht.html#a8f7ea60086c280bdf0ffd08859d8523e">kd_search</a> (RandomIt begin, RandomIt end, OutputIt output, const <a class="el" href="structppht_1_1point__t.html">point_t</a> &amp;p, long limit)</td></tr>
<tr class="separator:a8f7ea60086c280bdf0ffd08859d8523e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a794990442ae62f47b42fe2d47684ca60"><td class="memTemplParams" colspan="2">template&lt;class RandomIt &gt; </td></tr>
<tr class="memitem:a794990442ae62f47b42fe2d47684ca60"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceppht.html#a794990442ae62f47b42fe2d47684ca60">find_nearest</a> (RandomIt begin, RandomIt end, const <a class="el" href="structppht_1_1point__t.html">point_t</a> &amp;p, unsigned limit)</td></tr>
<tr class="separator:a794990442ae62f47b42fe2d47684ca60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f61e6440511b00746ab496ca16ed58c"><td class="memItemLeft" align="right" valign="top">static auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceppht.html#a2f61e6440511b00746ab496ca16ed58c">distance_to_line_squared</a> (const <a class="el" href="structppht_1_1point__t.html">point_t</a> &amp;pnt1, const <a class="el" href="structppht_1_1point__t.html">point_t</a> &amp;pnt2)</td></tr>
<tr class="separator:a2f61e6440511b00746ab496ca16ed58c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09260eb4004b9decd7ae86a0263afd51"><td class="memTemplParams" colspan="2">template&lt;class ForwardIt &gt; </td></tr>
<tr class="memitem:a09260eb4004b9decd7ae86a0263afd51"><td class="memTemplItemLeft" align="right" valign="top">ForwardIt&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceppht.html#a09260eb4004b9decd7ae86a0263afd51">postprocess</a> (ForwardIt begin, ForwardIt end, unsigned limit)</td></tr>
<tr class="separator:a09260eb4004b9decd7ae86a0263afd51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7b2af876fd481103e6263d9b5ec94a8"><td class="memItemLeft" align="right" valign="top">static std::set&lt; <a class="el" href="structppht_1_1point__t.html">point_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceppht.html#ac7b2af876fd481103e6263d9b5ec94a8">find_offsets</a> (<a class="el" href="classppht_1_1segment__t.html">segment_t</a> const &amp;segment, unsigned radius)</td></tr>
<tr class="memdesc:ac7b2af876fd481103e6263d9b5ec94a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a set of offsets that are within a radius.  <a href="namespaceppht.html#ac7b2af876fd481103e6263d9b5ec94a8">More...</a><br /></td></tr>
<tr class="separator:ac7b2af876fd481103e6263d9b5ec94a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f07cf00007b3c094373ca8b4c7bf6bd"><td class="memTemplParams" colspan="2">template&lt;template&lt; class &gt; class Raster&gt; </td></tr>
<tr class="memitem:a9f07cf00007b3c094373ca8b4c7bf6bd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classppht_1_1point__set.html">point_set</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceppht.html#a9f07cf00007b3c094373ca8b4c7bf6bd">scan</a> (<a class="el" href="classppht_1_1state.html">state</a>&lt; Raster &gt; &amp;s, <a class="el" href="classppht_1_1segment__t.html">segment_t</a> const &amp;segment, unsigned radius, unsigned max_gap)</td></tr>
<tr class="memdesc:a9f07cf00007b3c094373ca8b4c7bf6bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trace a scan channel.  <a href="namespaceppht.html#a9f07cf00007b3c094373ca8b4c7bf6bd">More...</a><br /></td></tr>
<tr class="separator:a9f07cf00007b3c094373ca8b4c7bf6bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >The basic namespace of the library. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a62df3910999f59d178dd7090a4c89d86" name="a62df3910999f59d178dd7090a4c89d86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62df3910999f59d178dd7090a4c89d86">&#9670;&nbsp;</a></span>status_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceppht.html#a62df3910999f59d178dd7090a4c89d86">ppht::status_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The status of a pixel in a <a class="el" href="classppht_1_1state.html">state</a> map. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a62df3910999f59d178dd7090a4c89d86a0f45ad41c1c3261e309b3fd0bcab017a" name="a62df3910999f59d178dd7090a4c89d86a0f45ad41c1c3261e309b3fd0bcab017a"></a>unset&#160;</td><td class="fielddoc"><p >Pixel is unset. </p>
</td></tr>
<tr><td class="fieldname"><a id="a62df3910999f59d178dd7090a4c89d86afb573f653d4d73258e47c80e98bad364" name="a62df3910999f59d178dd7090a4c89d86afb573f653d4d73258e47c80e98bad364"></a>pending&#160;</td><td class="fielddoc"><p >Pixel is set but not yet voted. </p>
</td></tr>
<tr><td class="fieldname"><a id="a62df3910999f59d178dd7090a4c89d86ae6c5099536830b50645dc1f77dfc4873" name="a62df3910999f59d178dd7090a4c89d86ae6c5099536830b50645dc1f77dfc4873"></a>voted&#160;</td><td class="fielddoc"><p >Pixel is set and voted. </p>
</td></tr>
<tr><td class="fieldname"><a id="a62df3910999f59d178dd7090a4c89d86a68622b152a1cf239b30f26696906b3eb" name="a62df3910999f59d178dd7090a4c89d86a68622b152a1cf239b30f26696906b3eb"></a>done&#160;</td><td class="fielddoc"><p >Pixel has been incorporated into a segment. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a2f61e6440511b00746ab496ca16ed58c" name="a2f61e6440511b00746ab496ca16ed58c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f61e6440511b00746ab496ca16ed58c">&#9670;&nbsp;</a></span>distance_to_line_squared()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto ppht::distance_to_line_squared </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structppht_1_1point__t.html">point_t</a> &amp;&#160;</td>
          <td class="paramname"><em>pnt1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structppht_1_1point__t.html">point_t</a> &amp;&#160;</td>
          <td class="paramname"><em>pnt2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a794990442ae62f47b42fe2d47684ca60" name="a794990442ae62f47b42fe2d47684ca60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a794990442ae62f47b42fe2d47684ca60">&#9670;&nbsp;</a></span>find_nearest()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RandomIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto ppht::find_nearest </td>
          <td>(</td>
          <td class="paramtype">RandomIt&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomIt&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structppht_1_1point__t.html">point_t</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac7b2af876fd481103e6263d9b5ec94a8" name="ac7b2af876fd481103e6263d9b5ec94a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7b2af876fd481103e6263d9b5ec94a8">&#9670;&nbsp;</a></span>find_offsets()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::set&lt; <a class="el" href="structppht_1_1point__t.html">point_t</a> &gt; ppht::find_offsets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classppht_1_1segment__t.html">segment_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>segment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>radius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a set of offsets that are within a radius. </p>
<p >The number of offsets generated is controlled by the <code>radius</code> parameter. For a radius \(r\), the returned offsets will be \(0,1,\ldots,r\) pixels from the origin, along the perpendicular to the <code>segment</code> parameter. Both directions are considered, so \(2^r+1\) offsets will be generated before duplicates are removed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">segment</td><td>used to determine the orientation of the perpendicular.</td></tr>
    <tr><td class="paramname">radius</td><td>determines the number of offsets to calculate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a non-empty set of offsets.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceppht.html#a9f07cf00007b3c094373ca8b4c7bf6bd" title="Trace a scan channel.">scan()</a> </dd></dl>

</div>
</div>
<a id="a65cf942dc09d432abd4bac48af8804ed" name="a65cf942dc09d432abd4bac48af8804ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65cf942dc09d432abd4bac48af8804ed">&#9670;&nbsp;</a></span>find_segments()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class State , class Accumulator  = accumulator&lt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classppht_1_1segment__t.html">segment_t</a> &gt; ppht::find_segments </td>
          <td>(</td>
          <td class="paramtype">State &amp;&amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structppht_1_1parameters.html">parameters</a> &amp;&#160;</td>
          <td class="paramname"><em>param</em> = <code><a class="el" href="structppht_1_1parameters.html">parameters</a>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::random_device::result_type&#160;</td>
          <td class="paramname"><em>seed</em> = <code>std::random_device{}()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simplified interface to the PPHT algorithm. </p>
<p >This function performs the full PPHT algorithm by iterating over the set points in the <code>state</code> matrix. The state matrix is destroyed in the process.</p>
<p >Typical use case:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classppht_1_1state.html">ppht::state</a> <a class="code hl_class" href="classppht_1_1state.html">state</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> y = 0; y &lt; height; ++y) {</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> x = 0; x &lt; width; ++x) {</div>
<div class="line">    <span class="keywordflow">if</span> (is_set(bitmap, x, y)) {</div>
<div class="line">      <a class="code hl_class" href="classppht_1_1state.html">state</a>.<a class="code hl_function" href="classppht_1_1state.html#ac924d3997ba5265607c271d27defe368">mark_pending</a>({x, y});</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> segments = <a class="code hl_function" href="namespaceppht.html#a65cf942dc09d432abd4bac48af8804ed">ppht::find_segments</a>(std::move(state));</div>
<div class="ttc" id="aclassppht_1_1state_html"><div class="ttname"><a href="classppht_1_1state.html">ppht::state</a></div><div class="ttdoc">The state class represents the current state of the algorithm.</div><div class="ttdef"><b>Definition:</b> state.hpp:28</div></div>
<div class="ttc" id="aclassppht_1_1state_html_ac924d3997ba5265607c271d27defe368"><div class="ttname"><a href="classppht_1_1state.html#ac924d3997ba5265607c271d27defe368">ppht::state::mark_pending</a></div><div class="ttdeci">void mark_pending(point_t const &amp;point)</div><div class="ttdoc">Mark a pixel in the raster as pending.</div><div class="ttdef"><b>Definition:</b> state.hpp:122</div></div>
<div class="ttc" id="anamespaceppht_html_a65cf942dc09d432abd4bac48af8804ed"><div class="ttname"><a href="namespaceppht.html#a65cf942dc09d432abd4bac48af8804ed">ppht::find_segments</a></div><div class="ttdeci">std::vector&lt; segment_t &gt; find_segments(State &amp;&amp;state, const parameters &amp;param=parameters{}, std::random_device::result_type seed=std::random_device{}())</div><div class="ttdoc">Simplified interface to the PPHT algorithm.</div><div class="ttdef"><b>Definition:</b> ppht.hpp:148</div></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">State</td><td>the class of the state parameter</td></tr>
    <tr><td class="paramname">Accumulator</td><td>the class to use for the accumulator</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>an initialized <a class="el" href="classppht_1_1state.html">ppht::state</a> object or something similar</td></tr>
    <tr><td class="paramname">param</td><td>optional tuning parameters to adjust the behavior of the algorithm</td></tr>
    <tr><td class="paramname">seed</td><td>a value to use as a seed for the URBG</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of line segments </dd></dl>

</div>
</div>
<a id="a8f7ea60086c280bdf0ffd08859d8523e" name="a8f7ea60086c280bdf0ffd08859d8523e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f7ea60086c280bdf0ffd08859d8523e">&#9670;&nbsp;</a></span>kd_search()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Dim = 0, class RandomIt , class OutputIt &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIt ppht::kd_search </td>
          <td>(</td>
          <td class="paramtype">RandomIt&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomIt&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIt&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structppht_1_1point__t.html">point_t</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Perform a modified kd-tree search on the elements of the given range.</p>
<p >Given a list of points [<code>begin</code>, <code>end</code>) and a reference point <code>p</code>, finds the intersection of the list and the closed disc centered at <code>p</code> with radius <code>limit</code>.</p>
<p >The template parameter <code>Dim</code> controls the scan mode of the function. The default 0 value starts the search by partitioning along the x-axis; a 1 would partition along the y-axis. Each recursive call toggles the mode.</p>
<dl class="section note"><dt>Note</dt><dd>The elements of the range will be shuffled as part of the search. This may invalidate iterators.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>the start of the sequence to search </td></tr>
    <tr><td class="paramname">end</td><td>the end of the sequence to search </td></tr>
    <tr><td class="paramname">output</td><td>where to store the results of the search </td></tr>
    <tr><td class="paramname">p</td><td>the center of the disc </td></tr>
    <tr><td class="paramname">limit</td><td>the radius of the disc </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Dim</td><td>the axis along which the range will be partitioned </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afa43fde4290ae78a00d1951918976316" name="afa43fde4290ae78a00d1951918976316"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa43fde4290ae78a00d1951918976316">&#9670;&nbsp;</a></span>make_scanner()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::unique_ptr&lt; <a class="el" href="structppht_1_1scanner.html">scanner</a> &gt; ppht::make_scanner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classppht_1_1segment__t.html">segment_t</a> &amp;&#160;</td>
          <td class="paramname"><em>segment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Factory function to create the appropriate scanner for the given segment. If the segment is not oriented correctly, then it will be corrected by exchanging the endpoints.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">segment</td><td>the segment to scan.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to an instance of <a class="el" href="structppht_1_1scanner.html">scanner</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>this function modifies its arguments. </dd></dl>

</div>
</div>
<a id="a09260eb4004b9decd7ae86a0263afd51" name="a09260eb4004b9decd7ae86a0263afd51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09260eb4004b9decd7ae86a0263afd51">&#9670;&nbsp;</a></span>postprocess()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIt &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ForwardIt ppht::postprocess </td>
          <td>(</td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9f07cf00007b3c094373ca8b4c7bf6bd" name="a9f07cf00007b3c094373ca8b4c7bf6bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f07cf00007b3c094373ca8b4c7bf6bd">&#9670;&nbsp;</a></span>scan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; class &gt; class Raster&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classppht_1_1point__set.html">point_set</a> ppht::scan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classppht_1_1state.html">state</a>&lt; Raster &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classppht_1_1segment__t.html">segment_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>segment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>max_gap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trace a scan channel. </p>
<p >Iterate over the points in the scan channel described by <code>segment:</code> these are the canonical points. For each canonical point, examine all of the pixels within the channel radius. If any are set, add the canonical point to the current segment. At the end of a gap of <code>max_gap</code> pixels, end the current segment and start a new one. Upon completion of the scan, return the longest segment found so far.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the state object to update</td></tr>
    <tr><td class="paramname">segment</td><td>the canonical segment of the scan channel</td></tr>
    <tr><td class="paramname">radius</td><td>the number of pixels to check around the canonical segment</td></tr>
    <tr><td class="paramname">max_gap</td><td>the number of consecutive missed pixels that can appear in a segment</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classppht_1_1point__set.html">point_set</a> around the longest segment found</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if no points are set in the scan channel</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceppht.html#ac7b2af876fd481103e6263d9b5ec94a8" title="Return a set of offsets that are within a radius.">find_offsets()</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>
